// vim: ft=arm

// C tile regs: v16 to v31, (scratch)
// - x19-x29 to preserve (but x19, x28, x29 not used) 
// - d8..d15 to preserve
// - v16 to v31, no need to preserve

.text
.align 4

// fn(ops: *const OpOrConst, xs: *mut $ti, len: usize) -> usize
// x0 <- ops, x1 <- xs, x2 <- len(xs)

.cpu generic+fp+simd
.global {{G}}arm64simd_act_f32_32n_{{suffix}}
{{G}}arm64simd_act_f32_32n_{{suffix}}:

    stp         d8, d9, [sp, #-16]!
    stp         d10, d11, [sp, #-16]!
    stp         d12, d13, [sp, #-16]!
    stp         d14, d15, [sp, #-16]!
    
    cmp         x3, 0
    beq         .ok

.outer_loop:
    mov         x5, x0          // x5 is "pc"
    ld1         {v0.4s, v1.4s, v2.4s, v3.4s}, [x1], 64
    ld1         {v4.4s, v5.4s, v6.4s, v7.4s}, [x1], 64
    sub         x1, x1, 128

.inner_loop:
    ldr         w6, [x5], 4        // x6 is fetched instruction at x5
    and         w7, w6, 0xffff

    cmp         w7, 0
    beq         .end_of_inner_loop
    cmp         w7, 14
    beq         .max_const

    b           .unsupported

.end_of_inner_loop:
    st1         {v0.4s, v1.4s, v2.4s, v3.4s}, [x1], 64
    st1         {v4.4s, v5.4s, v6.4s, v7.4s}, [x1], 64

    subs        x2, x2, 32
    bne         .outer_loop
    b           .ok

.max_const:
    ld1         { v24.s }[0], [x5], 4
    dup         v24.4s, v24.s[0]
    fmax        v0.4s, v0.4s, v24.4s
    fmax        v1.4s, v1.4s, v24.4s
    fmax        v2.4s, v2.4s, v24.4s
    fmax        v3.4s, v3.4s, v24.4s
    fmax        v4.4s, v4.4s, v24.4s
    fmax        v5.4s, v5.4s, v24.4s
    fmax        v6.4s, v6.4s, v24.4s
    fmax        v7.4s, v7.4s, v24.4s
    b .inner_loop

.unsupported:
    mov         x0, 1
    b           .return

.ok:
    mov         x0, 0

.return:
    ldp         d14, d15, [sp], #16
    ldp         d12, d13, [sp], #16
    ldp         d10, d11, [sp], #16
    ldp         d8, d9, [sp], #16

    ret
